package dev.pschmalz.wave_function_collapse.domain.collections_tuples;

import com.google.common.collect.ImmutableSet;
import dev.pschmalz.wave_function_collapse.domain.basic_elements.Tile;
import dev.pschmalz.wave_function_collapse.domain.basic_elements.TileSlot;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.*;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/**
 * must be initialized!
 */
public class TileSlotGrid {
    private final Set<Tile> tiles;
    private final Random random;
    /**
     * generated by init()
     */
    private TileSlot[][] tileSlots;
    private boolean initialized = false;
    private final int width, height;

    public Optional<TileSlot> get(int x, int y) {
        if(x < 0 || y < 0 || x >= tileSlots.length || y >= tileSlots[0].length)
            return Optional.empty();

        return Optional.of(tileSlots[x][y]);
    }

    public void set(TileSlot[][] tileSlots) {
        this.tileSlots = tileSlots;
    }

    public boolean isInitialized() {
        return initialized;
    }

    public boolean hasSuperposition() {
        return tileSlots().anyMatch(TileSlot::isSuperposition);
    }

    public Stream<TileSlot> tileSlots() {
        return Stream.of(tileSlots).flatMap(Stream::of);
    }

    public Stream<TileSlot> getAllWithSuperposition() {
        return tileSlots().filter(TileSlot::isSuperposition);
    }

    public Optional<TileSlot> getTileSlot_withLeastPossibilities() {
        return tileSlots().min(TileSlot::compareTo);
    }

    public int size() {
        return tileSlots.length * tileSlots[0].length;
    }

    public TileSlot[][] getTileSlotArray() {
        return tileSlots;
    }

    public boolean isDeadEnd() {
        return tileSlots().anyMatch(TileSlot::hasNoPossibilities);
    }

    public Set<Tile> getTileSet() {
        return tiles;
    }



    public Random getRandom() {
        return random;
    }

    public void init() {
        this.tileSlots =
                IntStream.range(0,width)
                        .mapToObj(x ->
                                IntStream.range(0,height)
                                .mapToObj(y -> new TileSlot(x, y, this))
                                .toArray(TileSlot[]::new)
                        ).toArray(TileSlot[][]::new);
    }

    public TileSlotGrid(Collection<Tile> tiles, int width, int height, Random random) {
        this.tiles = ImmutableSet.copyOf(tiles);
        this.width = width;
        this.height = height;
        this.random = random;
    }

    public TileSlotGrid copy() {
        var newGrid = new TileSlotGrid(tiles, width, height, random);
        newGrid.tileSlots =
                IntStream.range(0,width)
                        .mapToObj(x -> Arrays.copyOf(this.tileSlots[x],height))
                        .toArray(TileSlot[][]::new);

        return newGrid;
    }
}
